<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <meta http-equiv="X-UA-Compatible" content="ie=edge"> -->
    <title>前台</title>
</head>

<body>
    <div id="app">
        <div>1.v-text指令</div>
        <div v-text="{{aaa.aa.a}}"></div>
        <br />
        <div>2.{{指令</div>
        <div>{{aaa.b}} 啊啊啊啊啊{{aaa.a}}</div>
        <br />
        <div>3.输入框双向绑定</div>
        <div>{{aaa.a}}</div>
        <br />
        <input type="text" value="{{aaa.a}}">
        <input type="text" value="{{aaa.b}}">
        <br />
        <br />
        <div>4.v-html指令</div>
        <div v-html="{{html}}"></div>
        <div>4.列表循环</div>
        <div v-for="{{list:(item,index)}}">{{index}}{{item.a}} <span
                v-for="{{item.list:(childItem,childIndex)}}">{{childItem}}</span></div>
        <br />
        <div>5.v-show指令</div>
        <div v-show="{{aaa.b}}">可以看见我了{{aaa.b}}</div>
        <div v-show="{{!aaa.b}}">真正的我隐藏了</div>
        <br />
        <div>6. :指令</div>
        <div :style="{{'color:'+color}}">我是红色的</div>
        <div>7. 加减乘除</div>
        <div>{{1 + (2 / 5)}}</div>
    </div>
    <script>
        var qqqq = [1, 2, 3, 4, 5];
        var insert = new dataInsert("app", {
            aaa: {
                a: 111,
                b: 2222,
                aa: {
                    a: 222
                },
            },
            list: [{
                a: 1,
                list: [1, 2, 3, 4]
            }, {
                a: 2,
                list: [1, 2, 3, 4]
            }],
            html: "<a href='http://www.baidu.com'>百度</a>",
            color: "#F00"
        });
        setTimeout(function () {
            insert.setData({
                aaa: {
                    a: "aaa",
                    aa: {
                        a: "a11a1"
                    },
                },
            });
        }, 2000);
        setTimeout(function () {
            insert.setData({
                aaa: {
                    a: "啊啊啊",
                    b: 2222,
                    aa: {
                        a: "啊啊啊"
                    },
                },
                list: [{
                    a: "啊",
                    list: [1, 2, 3, 4]
                }, {
                    a: "哦",
                    list: [1, 2, 3, 4]
                }],
                color: "#0f0"
            });
        }, 6000);

        function trim(str) {
            return str.replace(/^(\s|\xA0)+|(\s|\xA0)+$/g, '');
        }

        function jsMatch(text, data, callback) {
            if (text && trim(text)) {
                var reg = /\{\{(.*?)\}\}/g;
                var backString = false;
                if (text.replace(reg, "")) {
                    backString = true;
                };
                var textList = text.match(reg);
                //条件列表
                var conditionList = [];
                //js方法列表
                var jsList = [];
                if (textList) {
                    var textLen = textList.length;
                    for (var t = 0; t < textLen; t++) {
                        var arrtext = textList[t].substring(2, textList[t].length - 2);
                        conditionList.push(arrtext);
                        for (var key in data) {
                            var keyReg = new RegExp(key, "g");
                            var matchList = arrtext.match(keyReg);
                            if (matchList) {
                                for (var m = 0; m < matchList.length; m++) {
                                    var x = arrtext.indexOf(matchList[m]);
                                    for (var w = 1; w < m + 1; w++) {
                                        x = arrtext.indexOf(matchList[m], x + 1);
                                    };
                                    if (x == 0) {
                                        arrtext = "data." + arrtext;
                                    } else {
                                        var value1 = arrtext.substring(x - 1, x);
                                        if (value1 != "." && value1 != "'" && value1 != '"' && value1 != ':') {
                                            arrtext = arrtext.substring(0, x) + "data." + arrtext.substring(x);
                                        };
                                    };
                                }
                            }
                        }
                        try {
                            jsList.push(arrtext);
                            var dataVal = eval(arrtext);
                            if (!backString && textLen <= 1) {
                                text = dataVal;
                            } else {
                                text = text.replace(textList[t], dataVal)
                            }
                        } catch (err) {
                            console.log(err);
                            text = false;
                        }
                    }
                    callback && callback(text, conditionList, jsList);
                    return text;
                } else {
                    callback && callback(false, conditionList, jsList);
                    return false;
                }
            } else {
                callback && callback(false, [], []);
                return false;
            }
        }

        function dataInsert(el, data) {
            var $el = document.getElementById(el);
            var domList = [];
            var waitWithList = [];

            function dataDiff(newData, oldData, jsonPath, arrPath) {
                for (var key in newData) {
                    jsonPath = jsonPath ? jsonPath + '.' + key : key;
                    arrPath = arrPath ? arrPath + '[' + key + ']' : key;
                    if (newData[key] instanceof Array) {
                        oldData[key] = newData[key];
                        render(newData[key], jsonPath, arrPath,"array");
                    } else if (newData[key] instanceof Object) {
                        if (oldData[key] && oldData[key] instanceof Object) {
                            dataDiff(newData[key], oldData[key], jsonPath, arrPath);
                        } else {
                            oldData[key] = newData[key];
                            render(newData[key], jsonPath, arrPath,"");
                        }
                    } else if (data[key] != newData[key]) {
                        oldData[key] = newData[key];
                        render(newData[key], jsonPath, arrPath,"");
                    }
                }
            }
            function render(res, jsonPath, arrPath,type) {
                console.log(res, jsonPath, arrPath);
                jsonPath = "data." + jsonPath;
                arrPath = "data." + arrPath;
                var len = domList.length;
                for (var index = 0; index < len; index++) {
                    var item = domList[index];
                    console.log(item.initValue);
                    if(type == "array"){
                        if(item.initValue == jsonPath || item.initValue == arrPath){

                        }
                    }
                }
                // var len = domList.length;
                // for (var index = 0; index < len; index++) {
                //     var item = domList[index];
                //     if (options && item.make == "v-for") {
                //         var showValue = jsMatch(item.initValue, options);
                //         if (showValue) {
                //             waitWithList = [];
                //             var forDomList = [];
                //             var listLen = showValue.length;
                //             var childData = {};
                //             for (var dataKey in data) {
                //                 childData[dataKey] = data[dataKey];
                //             }
                //             for (var itemIndex = 0; itemIndex < listLen; itemIndex++) {
                //                 childData[item.forConfig.item] = showValue[itemIndex];
                //                 childData[item.forConfig.index] = itemIndex;
                //                 var dom = domReplace(item.node.cloneNode(true), childData, false);
                //                 forDomList.push(dom);
                //                 if (item.getNextSibling) {
                //                     item.parent.insertBefore(dom, item.getNextSibling);
                //                 } else {
                //                     item.parent.insertBefore(dom, item.getNextSibling);
                //                 }
                //             }
                //             for (var r = 0; r < item.removeList.length; r++) {
                //                 item.parent.removeChild(item.removeList[r]);
                //             }
                //             item.removeList = forDomList;
                //             //处理元素
                //             if (waitWithList.length > 0) {
                //                 for (var a = 0; a < waitWithList.length; a++) {
                //                     var item = waitWithList[a];
                //                     if (item.value1) {
                //                         item.aims[item.type](item.value, item.value1);
                //                     } else {
                //                         item.aims[item.type](item.value);
                //                     }
                //                 }
                //             }
                //         }
                //     } else if (item.make == "v-show") {
                //         var showValue = jsMatch(item.initValue, data);
                //         if (item.oldValue !== showValue) {
                //             if (showValue) {
                //                 item.node.style.display = "inherit";
                //             } else {
                //                 item.node.style.display = "none";
                //             }
                //             item.oldValue = showValue;
                //         }
                //     } else {
                //         var showValue = jsMatch(item.initValue, data);
                //         if (showValue && item.oldValue != showValue) {
                //             if (item.type == "setAttribute") {
                //                 item.node.setAttribute(item.make, showValue);
                //                 item.oldValue = showValue;
                //             } else if (attrValue && item.node.nodeName == "INPUT") {

                //             } else {
                //                 item.node[item.type] = showValue;
                //                 item.oldValue = showValue;
                //             }
                //         }
                //     }
                // }
            }
            this.setData = function (options) {
                // for (var key in options) { //遍历json对象的每个key/value对,p为key
                //     data[key] = options[key];
                // }
                dataDiff(options, data, "", "");
                // render(options);
            };
            domReplace($el, data, true);
            //处理元素
            if (waitWithList.length > 0) {
                for (var a = 0; a < waitWithList.length; a++) {
                    var item = waitWithList[a];
                    if (item.value1) {
                        item.aims[item.type](item.value, item.value1);
                    } else {
                        item.aims[item.type](item.value);
                    }
                }
            }

            function domReplace(frag, data, store) {
                var childNodes = frag.childNodes;
                var childlen = childNodes.length;
                for (var i = 0; i < childlen; i++) {
                    var node = childNodes[i];
                    var txt = node.nodeValue;
                    var isChildlen = true;
                    var reg = /\{\{(.*?)\}\}/g; // 正则匹配{{}}
                    if (node.nodeName == "SCRIPT" || node.nodeName == "STYLE") {
                        isChildlen = false;
                        return;
                    }
                    if (node.nodeType === 3) {
                        var showValue = jsMatch(txt, data);
                        if (showValue) {
                            node.nodeValue = showValue;
                            if (store) {
                                domList.push({
                                    node: node,
                                    make: "",
                                    type: "nodeValue",
                                    oldValue: showValue,
                                    initValue: txt
                                });
                            }
                        }
                    } else if (node.nodeType === 1) {
                        var nodeAttr = node.attributes;
                        var attrLen = nodeAttr.length;
                        for (var j = 0; j < attrLen; j++) {
                            var attr = nodeAttr[j];
                            var name = attr.name;
                            var forConfig = {
                                item: "item",
                                index: "index",
                            };
                            var attrValue = attr.value;
                            if (name == "v-for") {
                                attrValue = attrValue.replace(/\:\((.*?)\,(.*?)\)/g, "");
                                forConfig.item = RegExp.$1;
                                forConfig.index = RegExp.$2;
                            }
                            if (name == ":style") {
                                name = "style";
                            }
                            jsMatch(attrValue, data, function (text, conditionList, jsList) {
                                var domConfig = {
                                    node: node,
                                    make: name,
                                    initValue: attrValue,
                                    oldValue: text
                                };
                                var waitWithState = false;
                                if (name == 'v-show') {
                                    if (text) {
                                        node.style.display = "inherit";
                                    } else {
                                        node.style.display = "none";
                                    }
                                    domConfig.type = "style";
                                    waitWithState = true;
                                } else if (name == "v-if") {

                                } else if (text) {
                                    if (node.nodeName == "INPUT") {
                                        node.value = text;
                                        domConfig.type = "value";
                                        getinput(node, jsList[0]);

                                        function getinput(node, jsNode, attrValue) {
                                            if (node.addEventListener) {
                                                node.addEventListener('input', function (e) {
                                                    var newVal = e.target.value;
                                                    eval(jsNode + "='" + newVal + "'");
                                                    render();
                                                });
                                            } else {
                                                node.onpropertychange = function (e) {
                                                    // render({}, attrValue);
                                                    var newVal = node.value;
                                                    eval(jsNode + "='" + newVal + "'");
                                                    render({}, attrValue);
                                                }
                                            }
                                        }

                                    } else if (name == 'v-text') {
                                        domConfig.type = "innerText";
                                        node.innerText = text;
                                        waitWithState = true;
                                    } else if (name == 'v-html') {
                                        domConfig.type = "innerHTML";
                                        node.innerHTML = text;
                                        waitWithState = true;
                                    } else if (name == 'v-for') {
                                        isChildlen = false;
                                        waitWithState = true;
                                        var getNextSibling = null;
                                        findSibling(node);

                                        function findSibling(dom) {
                                            var sibling = dom.nextSibling;
                                            if (sibling) {
                                                if (sibling.nodeName == "#text") {
                                                    findSibling(sibling);
                                                } else {
                                                    getNextSibling = sibling;
                                                }
                                            }
                                        }
                                        var getParentNode = node.parentNode;
                                        var listLen = text.length;
                                        var childData = {};
                                        var forDomList = new Array;
                                        for (var dataKey in data) {
                                            childData[dataKey] = data[dataKey];
                                        }
                                        for (var itemIndex = 0; itemIndex < listLen; itemIndex++) {
                                            childData[forConfig.item] = text[itemIndex];
                                            childData[forConfig.index] = itemIndex;
                                            var dom = domReplace(node.cloneNode(true), childData, false);
                                            forDomList.push(dom);
                                            if (getNextSibling) {
                                                waitWithList.push({
                                                    aims: getParentNode,
                                                    type: "insertBefore",
                                                    value: dom,
                                                    value1: getNextSibling,
                                                });
                                            } else {
                                                waitWithList.push({
                                                    aims: getParentNode,
                                                    type: "appendChild",
                                                    value: dom,
                                                });
                                            }
                                        }
                                        domConfig.removeList = forDomList;
                                        domConfig.getNextSibling = getNextSibling;
                                        domConfig.type = "v-for";
                                        domConfig.parent = getParentNode;
                                        domConfig.parent = getParentNode;
                                        domConfig.forConfig = forConfig;
                                        waitWithList.push({
                                            aims: getParentNode,
                                            type: "removeChild",
                                            value: node
                                        });
                                    } else {
                                        node.setAttribute(name, text);
                                        domConfig.type = "setAttribute";
                                    }
                                }
                                if (store) {
                                    domList.push(domConfig);
                                } else if (waitWithState) {
                                    waitWithList.push({
                                        aims: node,
                                        type: "removeAttribute",
                                        value: name,
                                    });
                                }
                            });
                        }
                    }
                    // 如果还有子节点，继续递归replace
                    if (isChildlen && node.childNodes && node.childNodes.length) {
                        domReplace(node, data, store);
                    }
                }
                return frag;
            }
        }
    </script>
</body>

</html>